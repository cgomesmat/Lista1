Nome: Carlos Alexandre Gomes da Silva
Matrícula: 20220032813 - Engenharia Elétrica

Questao 1: 

O trecho de programa é:

int i=3,j=5;
int *p, *q;
p = &i;
q = &j;

Determine o valor das seguintes expressões, justificando o porquê de cada resultado:

a)p == &i;
b)*p - *q;
c)**&p;
d) 3 - *p/(*q) + 7;

<resposta da questao 1>

a)p == &i 
Essa sentença é verdadeira. De fato, a variável i é inteira enquanto a variável p é um ponteiro para inteiro (portanto recebe um endereço onde está armazenado um inteiro). Na terceira linha do trecho do programa dado o ponteiro p recebe exatamente o endereço da variável inteira i através do operador "&" posto na frente da variável i, o comando &i faz retornar exatemente o endereço onde está guardada a variável i na memória.

b)Como p e q são ponteiros para inteiros, no corpo do programa *p e *q  recuperam os conteúdos dos endereços para os quais os ponteiros p e q apontam. Assim, 
*p-*q=(conteúdo do endereço para onde p aponta) - (conteúdo do endereço para onde p aponta). Ora, como nas duas últimas linhas temos p=&i  e  q=&j, segue que
*p - *q = 3-5=-2.

c)Na liguagem C, sabemos que "&" é o operador endereço, ou seja, quando colocamos o símbolo "&" antes de uma variável, o retorno é o endereço de memória onde aquela variável está guardada. por outro lado, o operador "*" quando colocando antes de uma variável no corpo  do programa oferece como retorno o conteúdo daquela variável.  Assim, **&p é interpretado da seguinte forma: &p retorna o endereço de onde está guardado a variável do tipo ponteiro para inteiro "p". Portanto *&p retorna o conteúdo  contido no endereço de memória &p, que é o endereço para o qual p aponta. Por fim, **&p nos oferecerá como resposta o conteúdo de p, ou seja, o mesmo que *p que no caso é o valor de i, que é 3.

d)Como *p e *q correspondem aos conteúdos dos ponteiros para inteiros p e q , segue que  expressão  3 - *p/(*q) + 7 corresponde a  3 - 3/5 + 7=3-0+7=10.


----------------------------------------------------------------------------------------------------------------------

Questao 2: 

Mostre o que será impresso por programa supondo que a variável i ocupa o endereço 4094 na
memória e que nessa arquitetura os inteiros possuem 2 bytes de tamanho.

main(){
int i=5, *p;
p = &i;
printf("%p %p %d %d %d %d\n", p, p+1, *p+2, **&p, 3**p, **&p+4);
}

<resposta da questao 2>

Como p é um ponteiro para inteiros e na terceira linha do programa p recebe o endereço da variável i, segue que na impressão no lugar onde aparece o p aparecerá 4094, que é o que p guarda nesse momento (o endereço da variável i). 
Como nessa arquitetura os inteiros possuem 2 bytes, no lugar onde aparece p+1 (no comando printf) será impresso na tela  o valor 4094+2=4096. 

No lugar de *p+2 será impresso o conteúdo de p adicionado de 2, ou seja 5+2=7, visto que *p=5 (pois p aponta para o endereço da variável i, onde está guardado o conteúdo 5). 

No item (c) da questão 1, já discutimos que **&p corresponde a *p, ou seja, o conteúdo do ponteiro p, que no caso é 5.

O comando 3**p significa 3 vezes o conteúdo de p, ou seja 3 x 5 = 15 (o primeiro asterisco representa a operação de multiplicação, já o segundo representa a exibição do conteúdo do endereço para onde o ponteiro p aponta). 

Por fim, **&p+4 corresponde a soma entre o conteúdo do ponteiro p (pois **&p=*p=5) e o número 4, ou seja, 
**&p+4=5+4=9.

----------------------------------------------------------------------------------------------------------------------

Questao 3: 

Se i e j são variáveis inteiras e p e q ponteiros para int, quais das seguintes expressões de
atribuição são ilegais? Justifique.

a)p = &i;
b)*q = &j;
c)p = &*&i;
d)i = (*&)j;
e)i = *&j;
f)i = *&*&j;
g)q = *p;
h)i = (*p)++ + *q;

<resposta da questao 3>

a)A expressão p = &i faz sentido, pois &i retorna o endereço no qual está armazenado o contaúdo da variável inteira i e sendo p um ponteiro para inteiro o tipo de dado que ele pode receber é exatamente um endereço de uma variável do tipo inteira. Portanto a expessão p=&i atribui ao ponteiro o endereço de memória onde está guardado o conteúdo da varíavel i. 

b)A expressão *q = &j é permitida. Ela faz com que o ponteiro para inteiro q aponte para o endereço da variável inteira j. Por exemplo,

int j = 10;
int *p = &j; // p aponta para o endereço de j
printf("%d", *p); // Isso imprimirá o valor de j, ou seja, 10



c) A expressão p = &*&i faz sentido em C. Vamos analisar essa expressão passo a passo:

&i: Obtém o endereço da variável i.
*: Desreferencia o endereço obtido em &i, ou seja, retorna o valor armazenado nesse endereço, que é o valor da variável i.
&: Obtém o endereço do valor retornado na etapa anterior.
p =: Atribui esse endereço ao ponteiro p.
Portanto, no final, o ponteiro p estará apontando para o endereço da variável i.

d) A expressão i = (*&)j não é válida em C, os parênteses em geral dão a ideia de prioridade, portanto não faz sentido (*&), visto que * e & são operadores que agem sobre variáveis e no interior dos parênteses (que  teria prioridade para o compilador) nesse caso * e & não agem sobre nenhuma variável.

e) A expressão i = *&j faz sentido em C. Vejamos como explicar o que essa expressão faz:

&j: Retorna o endereço da variável j.
*: Desreferencia o endereço obtido em &j, ou seja, acessa o valor armazenado nesse endereço.
i =: Atribui esse valor à variável i.
Então, em resumo, i receberá o valor de j, o que faz pleno sentido pois tanto i como j são variáveis do tipo inteiro.


f)A expressão i = *&*&j faz sentido em C. Vejamos como explicar o que essa expressão faz:

&j: Retorna o endereço da variável j.
*: Desreferencia o endereço obtido em &j, ou seja, acessa o valor armazenado nesse endereço, que é o valor da variável j.
&: Obtém o endereço do valor obtido na etapa anterior, que é o endereço de j.
*: Desreferencia o endereço obtido em &, ou seja, acessa o valor armazenado nesse endereço, que é o valor de j.
i =: Atribui esse valor à variável i.

g)Em C, a expressão q=*p faz sentido. Ela atribuiu ao ponteiro q o conteúdo do ponteiro p. Vejamos um exemplo:
 
    int x = 42;
    int *p, *q;

    q = &x; // q aponta para o endereço de x
    p = *q; // p recebe o valor apontado por q

    printf("O valor de p é: %d\n", p); // Imprime o valor que está armazenado no local de memória para onde p aponta, ou seja, o valor de x que é 42.

h)A expressão i = (*p)++ + *q faz sentido em C. Vejamos:

(*p)++: Desreferencia o ponteiro p, acessa o valor para o qual p está apontando e então incrementa esse valor em 1. 

O operador ++ após o parêntese faz o pós-incremento, o que significa que primeiro o valor é usado na expressão e depois é incrementado.

*q: Desreferencia o ponteiro q, acessa o valor para o qual q está apontando.

Depois disso, os valores desreferenciados de p e q são somados o valor final é atribuído à variável i.


----------------------------------------------------------------------------------------------------------------------

Questao 4: 


Determine o que será mostrado pelo seguinte programa (compile-o, execute-o e verifique se
foram obtidas as respostas esperadas, justificando o porque de cada uma).

#include <stdio.h>
int main() {
int valor;
int *p1;
float temp;
float *p2;
char aux;
char *nome = "Ponteiros";
char *p3;
int idade;
int vetor[3];
int *p4;
int *p5;

/* (a) */
valor = 10;
p1 = &valor;
*p1 = 20;
printf("%d \n", valor);

/* (b) */
temp = 26.5;
p2 = &temp;
*p2 = 29.0;
printf("%.1f \n", temp);

/* (c) */
p3 = &nome[0];
aux = *p3;
printf("%c \n", aux);

/* (d) */
p3 = &nome[4];
aux = *p3;
printf("%c \n", aux);

/* (e) */
p3 = nome;
printf("%c \n", *p3);

/* (f) */
p3 = p3 + 4;
printf("%c \n", *p3);

/* (g) */
p3--;
printf("%c \n", *p3);

/* (h) */
vetor[0] = 31;
vetor[1] = 45;
vetor[2] = 27;
p4 = vetor;
idade = *p4;
printf("%d \n", idade);

/* (i) */
p5 = p4 + 1;
idade = *p5;
printf("%d \n", idade);

/* (j) */
p4 = p5 + 1;
idade = *p4;
printf("%d \n", idade);

/* (l) */
p4 = p4 - 2;
idade = *p4;
printf("%d \n", idade);

/* (m) */
p5 = &vetor[2] - 1;
printf("%d \n", *p5);

/* (n) */
p5++;
printf("%d \n", *p5);
return(0);
}

<resposta da questao 4>

O resultado da execução do programa foi o seguinte:

20 
29.0 
P 
e 
P 
e 
t 
31 
45 
27 
31 
45 
27 

Vamos à análise dos resultados:

Trecho (a): A variável valor inicia com o conteúdo 10, o ponteiro p1 recebe o endereço da variável valor, depois o conteúdo do endereço para onde p1 aponta é modificado para 20 e por fim é impresso o 20, como é esperado.

Trecho (b): A variável temp recebe inicialmente o valor 26.5. Em seguida o ponteiro p2 recebe o endereço de memória onde está guardado o conteúdo da variável temp. Em seguida o conteúdo do endereço para onde p2 aponta recebe o valor 29.0. Por fim é impresso o valor 29.0, como o esperado.

Trecho (c): Nesse trecho o ponteiro p3 (do tipo char) recebe o endereço correspondente a primeira posição da variável nome (do tipo char), cujo conteúdo é a palavra "Ponteiros". Dessa forma p3 aponta para o endereço de memória onde está guardada a letra P. No passo seguinte a variável aux (do tipo char) recebe o conteúdo do endereço para onde p3 aponta, ou seja recebe a letra P. Por fim, é impresso o conteúdo da variável aux, que é justamente a letra P.  


Trecho (d):  Nesse trecho o ponteiro p3 (do tipo char) recebe o endereço correspondente a posição 4 da variável nome (do tipo char), cujo conteúdo é a palavra "Ponteiros". Dessa forma p3 aponta para o endereço de memória onde está guardada a letra "e" (lembre que o índice 4 cooresponde a quinta letra). No passo seguinte a variável aux (do tipo char) recebe o conteúdo para onde p3 aponta, ou seja recebe a letra "e". Por fim, é impresso o conteúdo da variável aux, que é justamente a letra "e".  


Trecho (e): Nesse trecho o ponteiro p3 recebe o conteúdo da variável nome (ponteiro para char, que aponta para o endereço de memória onde está guardado o conteúdo "Ponteiros"). Por fim, ao imprimir *p3 será impresso o conteúdo do endereço de memória para onde p3 aponta que contém a letra P, que é a letra que está na primeira posição da variável nome.

Trecho (f): Nesse trecho, o conteúdo atual de p3 (que é o endereço de memória no qual está guardada a letra P) será acrescido de 4 unidades (o ponteiro p3 é do tipo char que ocupa 1 byte). Assim o novo valor assumido por p3 será correspondente ao conteúdo de 4 letras após a letra P na palavra Ponteiros, ou seja, a letra "e".

Trecho (g): Nesse techo, o conteúdo atual de p3, que é o endereço onde está guardada a letra "e" da palavra Ponteiros será modificado para uma unidade a menos, ou seja, p3 passará a apontar  para o endereço de memória onde se enconta a letra antes do "e" que é a letra "t". Por isso na execusão do programa o comando printf("%c \n", *p3) imprime a letra "t".

Trecho (h): Nesse trecho do programa, a primeira posição da variável vetor (que é um array) recebe o valor 31, a segunda posição recebe 45 e a terceira posição recebe 27, ou seja, vetor=(31,45,27). Em seguida o ponteiro p4 aponta  para o endereço onde está guardada a variável vetor. Em seguida a variável idade recebe o conteúdo de p4, que é o conteúdo do endereço para onde p4 aponta, ou seja, a primeira posição da variável vetor, isto é,v[0] que é igual a 31, o que faz com que o comando printf("%d \n", idade) imprima o valor 31 na tela.

Trecho (i): Nesse trecho o ponteriro p5 recebe o conteúdo do ponteiro p4+1. Como nesse momento o conteúdo do endereço para onde p4 aponta era 31, segue que p5 passa a apontar para o endereço de memória correspondente a próxima posição da vaiável vetor, ou seja p5 passa a assumir o valor 45 que é a segunda posição da variável vetor.

Trecho (j): Nesse trecho é atribuido ao ponteiro p4 o conteúdo de p5+1.  Como nesse momento p5 apontava para o endereço de memória onde estada guardado o número 45 (segunda posição da variável vetor), agora como "+1" , p4 passa a apontar para o endereço de memória onde está guardado o número 27, que é o conteúdo guardado na terceira posição da variáel vetor. Por isso o comando printf("%d \n", idade) imprime o valor 27 na tela.


Trecho (l): Nesse trecho do programa o ponteiro p4, que neste momento apontava para o endereço de memória onde está  27 (terceira posição da variável vetor) recebe o conteúdo de p4-2, ou seja, "recua" duas unidades na memória, passando a apontar para o endereço de memória onde está guardado o número 31, que é a primeira posição da variável vetor. Diante do exposta, o comando printf("%d \n", idade) imprime na tela o valor 31.


Trecho (m): Nesse trecho do programa o ponteiro p5 recebe o conteúdo &vetor[2] - 1, ou seja, recebe o endereço da segunda posição da variável vetor vetor=(vetor[0],vetor[1],vetor[2])=(31,45,27). Ou seja, p5 passa a apontar para o endereço onde está guardada o número 45. Diante do exposto o comando printf("%d \n", *p5) imprime o o conteúdo de p5 que agora é 45.

Trecho (n): Nesse trecho do programa o ponteiro p5 recebe o conteúdo p5+1. Como neste momento p5 estava apontando para o endereço correspondente a segunda posição da variável vetor, p5 passa a apontar para o endereço correspondente a terceira posição da variável vetor, ou seja, p5 passa a apontar para oendereço de memória onde encontra-se o número 27. Por isso, o comando printf("%d \n", *p5) imprime o número 27 na tela.




----------------------------------------------------------------------------------------------------------------------


Questao 5:

Determine o que será mostrado pelo seguinte programa (compile-o, execute-o e explique se
foram obtidas as respostas esperadas).

int main(void){
float vet[5] = {1.1,2.2,3.3,4.4,5.5};
float *f;
int i;
f = vet;
printf("contador/valor/valor/endereco/endereco\n");
for(i = 0 ; i <= 4 ; i++){
printf("i = %d",i);
printf(" vet[%d] = %.1f",i, vet[i]);
printf(" *(f + %d) = %.1f",i, *(f+i));
printf(" &vet[%d] = %X",i, &vet[i]);
printf(" (f + %d) = %X",i, f+i);
printf("\n");
}
}


<resposta da questao 5>

O resultado da execução do programa foi o seguinte:

contador/valor/valor/endereco/endereco
i = 0 vet[0] = 1.1 *(f + 0) = 1.1 &vet[0] = C2497CC0 (f + 0) = C2497CC0
i = 1 vet[1] = 2.2 *(f + 1) = 2.2 &vet[1] = C2497CC4 (f + 1) = C2497CC4
i = 2 vet[2] = 3.3 *(f + 2) = 3.3 &vet[2] = C2497CC8 (f + 2) = C2497CC8
i = 3 vet[3] = 4.4 *(f + 3) = 4.4 &vet[3] = C2497CCC (f + 3) = C2497CCC
i = 4 vet[4] = 5.5 *(f + 4) = 5.5 &vet[4] = C2497CD0 (f + 4) = C2497CD0


O programa funciona da seguinte forma: 

A variável inteira i funcionará como um contador pois vai sendo incrementada de 1 em 1 unidade durante a excução do programa. A variável i assume inicialmente o valor 0,  e enquanto é menor que 4 ela vai sendo incrementada de 1 em 1 unidade. Para cada valor de i=0,1,2,3 são impressos na tela os seguintes resultados:

printf("i = %d",i): imprime o valor atual da variável i (o contador).

printf(" vet[%d] = %.1f",i, vet[i]): Imprime com uma casa decimal o valor do elemento que ocupa a posição "i" dentro do vetor vet. Isto é, vet[i] é o elemento que ocupa a posição i dentro do vetor (lembrando que i começa do valor 0).

printf(" *(f + %d) = %.1f",i, *(f+i)): Imprime com uma cada decimal o valor que está guardado na posição para a qual o ponteiro *(f + i)  aponta para cada valor de i=0,1,2,3,4.

printf(" &vet[%d] = %X",i, &vet[i]); para cada i=0,1,2,3,4 imprime em hexadecimal (o formato %X indica isso)  o endereço onde está guardado o valor assumido por vet[i], ou seja, o endereço do conteúdo corrrespondente a posição i no vetor vet.

printf(" (f + %d) = %X",i, f+i): Imprime em hexadecimal (o formato %X indica isso) o endereço para onde aponta o ponteiro f+i para cada valor de i=0,1,2,3,4.

printf("\n") indica que ocorererá uma quebra de linha.


----------------------------------------------------------------------------------------------------------------------

Questao 6:
Assumindo que pulo[] é um vetor do tipo int, quais das seguintes expressões referenciam o
valor do terceiro elemento do vetor?

a) *(pulo + 2);
b) *(pulo + 4);
c) pulo + 4;
d) pulo + 2;

<resposta da questao 6>

Alternativa (a). Em C, as posições dos vetores são sempre enumeradas a partir do 0. Então a terceira posição de um vetor está associada ao índice 2. Assim , o comando *(pulo + 2) coresponde ao conteúdo da posição 2 do vetor pulo. Então, *(pulo + 2) simplesmente acessa o valor armazenado no terceiro elemento do vetor pulo.



----------------------------------------------------------------------------------------------------------------------

Questao 7:

Considerando a declaração
int mat[4], *p, x;
quais das seguintes expressões são válidas? Justifique.

p = mat + 1;
p = mat;
p = mat;
x = (*mat);



<resposta da questao 7>

Todas são válidas! Nesse caso, mat[4] é um vetor de inteiros com 4 elementos. *p é um ponteiro para um inteiro. x é uma variável inteira. Assim, quando você executa o comando p = mat + 1, você está atribuindo a p o endereço do segundo elemento do vetor mat. Então, depois desse comando, p estará apontando para o segundo elemento do vetor mat. Isso significa que *p agora acessará o valor armazenado no segundo elemento do vetor mat. A expressão p = mat faz com que o ponteiro p aponte para o local da memória onde está guardada a primeira posição do vetor mat. Por fim,  *mat dereferencia o ponteiro mat, ou seja, acessa o valor armazenado no primeiro elemento do vetor. Portanto, (*mat) resulta no valor do primeiro elemento de mat. Então, depois desse comando, x conterá o valor do primeiro elemento do vetor mat.



----------------------------------------------------------------------------------------------------------------------

Questao 8:

O que fazem os seguintes programas em C?

PROGRAMA 1

int main(){
int vet[] = {4, 9, 13};
int i;
for(i=0;i<3;i++){
printf("%d ", *(vet+i));
}

PROGRAMA 2

int main(){
int vet[] = {4, 9, 13};
int i;
for(i=0;i<3;i++){
printf("%X ",vet+i);
}
}

<resposta da questao 8>


O progama 1 inicia atribuindo ao vetor ver as entradas (4,9,13). Em seguida é introduzida uma variável inteira i para funcionar como o contador para cada passo loop do programa (i variando de 0 a 3). Para cada valor de i  é impresso o valor encontrado na posição vet+i, ou seja serão impressos os valores vet[0]=4,vet[1]=9 e vet[2]=13.

O programa 2 Inicia atribuindo ao vetor ver as entradas (4,9,13) Em seguida é introduzida uma variável inteira i para funcionar como o contador para cada passo loop do programa (i variando de 0 a 3). Para cada valor de i  é impresso o valor hexadecimal correspondente ao endereço de memória onde está guardado o conteúdo de vet+i, ou seja serão impressos em hexadecimal os endereços de vet[0], vet[1] e vet[2].


----------------------------------------------------------------------------------------------------------------

Questao 9:

Qual será a saída do seguinte programa

#include <stdio.h>
struct teste{
int x = 3;
char nome[] = "jose";
};
main(){
struct teste *s;
printf("%d", s->x);
printf("%s", s->name);
}

<resposta da questao 9>

Ao tentar compiplar o código acima não conseguimos gerar nenhuma saída, apenas algumas mensagens de erro vindas do compilador. A  seguir explicaremos os erros que identificamos e em seguida sugerimos algumas possíveis correções para que o programa possa funcionar.

a)Não há  uma declaração para o tipo de retorno da função main. Normalmente usamos int main() no lugar de main().

b)Não é possível inicializar membros de uma estrutura na declaração da estrutura em C. Portanto, a inicialização int x = 3; e char nome[] = "jose"; não é permitida.

c)O programa está tentando acessar membros de uma estrutura antes de alocar memória para ela.

Uma sugestão para para corrigir esses erros seria o seguinte código:


#include <stdio.h>

struct teste {
    int x;
    char nome[]; 
};

int main() {
    struct teste *s; // Declaração de um ponteiro para uma estrutura 'teste'
    
    s = malloc(sizeof(struct teste)); // Aloca memória para a estrutura 'teste'
    
    // Atribui valores aos membros da estrutura 'teste'
    s->x = 3;
    strcpy(s->nome, "Jose"); // Usamos strcpy() para copiar a string para 'nome'
    
    // Imprime os valores dos membros da estrutura 'teste'
    printf("%d\n", s->x);
    printf("%s\n", s->nome);
    
    free(s); // Libera a memória alocada
    
    return 0;
}

Com esse código a saída do programa seria: 3 jose

------------------------------------------------------------------------------------------------------------------

Questao 10:

Qual será a saída do seguinte programa

#include <stdio.h>
void main(){
int const *x = 3;
printf("%d", ++(*x));
}

<resposta da questao 10>

Ao tentar executar o programa acima não consegui gerar nenhuma saída, exceto algumas mensagens de erro vindas do compilador. Analizando o código identificamos alguns erros. A seguir apontamos esses erros e suas possíveis correções:

Você está tentando atribuir o valor 3 a um ponteiro constante para inteiro (int const *x), o que não é permitido diretamente em C. 

Além disso, você está tentando modificar o valor apontado pelo ponteiro x usando o operador de incremento (++(*x)), mas como x é um ponteiro para uma constante, isso também causará um erro.

Uma possível modificação que faria o programa funcionar seria  o seguinte:


#include <stdio.h>

int main() {
    int *x = NULL; // Declara um ponteiro para inteiro
    int y = 10; // Declara uma variável inteira y com valor 3
    x = &y; // Atribui o endereço de y ao ponteiro x
    
    printf("%d", ++(*x)); // Incrementa o valor apontado por x e imprime
    
    return 0;
}

Com esse código acima a saída do programa é 11.


---------------------------------------------------------------------------------------------------------

Questao 11:

Seja x um vetor de 4 elementos, declarado da forma TIPO x[4]. Suponha que depois da declaração, x esteja armazenado no endereço de memória 4092 (ou seja, o endereço de x[0]). Suponha também que na máquina seja usada uma variável do tipo char ocupa 1 byte, do tipo int ocupa 2 bytes, do tipo float ocupa 4 bytes e do tipo double ocupa 8 bytes. Quais serão os valores de x+1, x+2 e x+3 se:

a)x for declarado como char?
b)x for declarado como int?
c)x for declarado como float?
d)x for declarado como double?
Implemente um programa de computador para testar estas suposições e compare as respostas oferecidas pelo programa com as respostas que você idealizou.


<resposta da questao 11>

a)Se x for declarado como um vetor de char, então x+1, x+2 e x+3 apontarão para os endereços subsequentes na memória, onde cada endereço é deslocado pelo tamanho de um elemento do tipo char. Lembrando  que um char ocupa 1 byte, quando avançamos 1, 2 ou 3 elementos na memória, estamos avançando 1, 2 ou 3 bytes, respectivamente.

Supondo que x começa no endereço de memória 4092, temos:

x+1 estará em 4093
x+2 estará em 4094
x+3 estará em 4095

Isso ocorre porque cada char ocupa 1 byte e, ao somar 1 ao endereço de x, você avança 1 byte na memória.

b)Se x for declarado como um vetor de int, então x+1, x+2 e x+3 apontarão para os endereços subsequentes na memória, onde cada endereço é deslocado pelo tamanho de um elemento do tipo int.

Dado que um int ocupa 2 bytes, quando avançamos 1, 2 ou 3 elementos na memória, estamos avançando 2, 4 ou 6 bytes, respectivamente.

Dado que x começa no endereço de memória 4092, temos:

x+1 estará em 4094 (4092 + 2)
x+2 estará em 4096 (4092 + 2*2)
x+3 estará em 4098 (4092 + 3*2)

Isso ocorre porque cada int ocupa 2 bytes e, ao somar 1 ao endereço de x, você avança 2 bytes na memória.

c) Se x for declarado como um vetor de float, então x+1, x+2 e x+3 apontarão para os endereços subsequentes na memória, onde cada endereço é deslocado pelo tamanho de um elemento do tipo float.

Dado que um float ocupa 4 bytes, quando avançamos 1, 2 ou 3 elementos na memória, estamos avançando 4, 8 ou 12 bytes, respectivamente.

Dado que x começa no endereço de memória 4092, temos:

x+1 estará em 4096 (4092 + 4)
x+2 estará em 4100 (4092 + 2*4)
x+3 estará em 4104 (4092 + 3*4)

Isso ocorre porque cada float ocupa 4 bytes e, ao somar 1 ao endereço de x, você avança 4 bytes na memória.


d)Se x for declarado como um vetor de double, então x+1, x+2 e x+3 apontarão para os endereços subsequentes na memória, onde cada endereço é deslocado pelo tamanho de um elemento do tipo double.

Dado que um double ocupa 8 bytes, quando avançamos 1, 2 ou 3 elementos na memória, estamos avançando 8, 16 ou 24 bytes, respectivamente.

Dado que x começa no endereço de memória 4092, temos:

x+1 estará em 4100 (4092 + 8)
x+2 estará em 4108 (4092 + 2*8)
x+3 estará em 4116 (4092 + 3*8)

Isso ocorre porque cada double ocupa 8 bytes e, ao somar 1 ao endereço de x, você avança 8 bytes na memória.

A seguir mostramos um programa C que verifica as afirmações acima.



// PROGRAMA EM C

a)Para  Char

#include <stdio.h>

int main() {
    char x[4]; // Declaração de um vetor de 4 elementos do tipo char
    char *ptr = x; // Declaração de um ponteiro para o vetor x

    printf("Endereço de x[0]: %p\n", (void *)ptr); // Imprime o endereço de x[0]
    printf("Endereço de x+1: %p\n", (void *)(ptr + 1)); // Imprime o endereço de x+1
    printf("Endereço de x+2: %p\n", (void *)(ptr + 2)); // Imprime o endereço de x+2
    printf("Endereço de x+3: %p\n", (void *)(ptr + 3)); // Imprime o endereço de x+3

    return 0;
}

Endereço de x[0]: 0x7fffcdead42c
Endereço de x+1: 0x7fffcdead42d
Endereço de x+2: 0x7fffcdead42e
Endereço de x+3: 0x7fffcdead42f

Como em Hexadecimal c=12, d=13, e=14 e f=15, temos que os endereços exibidos acima são consecutivos.

Para int, float e double o programa é completamente análogo apenas redefinindo x[4] para os tipos int, float e double.


----------------------------------------------------------------------------------------------------------------------

Questao 12:

Suponha que as seguintes declarações tenham sido realizadas:

float aloha[10], coisas[10][5], *pf, value = 2.2;
int i=3;

Identifique quais dos seguintes comandos é válido ou inválido:

a)aloha[2] = value;
b)scanf("%f", &aloha);
c)aloha = "value";
d)printf("%f", aloha);
e)coisas[4][4] = aloha[3];
f)coisas[5] = aloha;
g)pf = value;
h)pf = aloha;

<resposta da questao 12>

a) aloha[2] = value é válida e atribuirá o valor de 2.2 ao terceiro elemento do array aloha.

b) A expressão scanf("%f", &aloha) não é válida. Quando você usa %f como um especificador de formato com scanf, ele espera receber  uma variável do tipo float. No entanto, aloha é um array de floats, não um float único.

c)A expressão aloha = "value" não é válida pois Em C, um array é uma sequência de elementos do mesmo tipo armazenados em locais de memória contíguos. Quando você declara um array como float aloha[10], você está alocando espaço para 10 valores do tipo float.

Por outro lado, "value" é uma string literal em C, representando um array de caracteres terminado por um caractere nulo ('\0'). Não é possível atribuir diretamente uma string a um array de float como aloha.

Se você deseja atribuir o valor da variável value ao primeiro elemento do array aloha, pode fazer isso da seguinte forma:aloha[0] = value;

d)A expressão printf("%f", aloha) não seria válida em um programa C, pois aloha é um array de floats, e o especificador de formato %f é destinado para impressão de valores float individuais, não para arrays.

Para imprimir os elementos individuais do array aloha, você precisaria iterar sobre o array e imprimir cada elemento separadamente. Por exemplo:

for (int j = 0; j < 10; j++) {
    printf("%f ", aloha[j]);
}


e)A expressão coisas[4][4] = aloha[3] é válida!.Essa expressão atribui o valor do elemento aloha[3] ao elemento coisas[4][4]. No entanto, vale ressaltar que os índices em C começam do zero, então coisas[4][4] refere-se ao quinto elemento na quinta linha do array bidimensional coisas, enquanto aloha[3] refere-se ao quarto elemento do array unidimensional aloha.

f)A expressão coisas[5] = aloha não é válida. De fato, "coisas" é um array bidimensional portanto cada um dos seus elmentos é localizado a partir de dois índices. Já aloha é um array unidimensional. 

Se você deseja atribuir os valores de aloha à uma linha (índice 5) de coisas, teria que fazer isso elemento por elemento, ou seja, coisas[5][i] = aloha[i] em um loop.


g)A expressão pf = value não faz sentido pois pf é um ponteiro para float (e portanto deve receber como contaúdo um endereço de memória). Já value é um float onde está guardado o valor 2.2.

h)A expressão pf=aloha faz sentido. Nessa expressão, pf é um ponteiro para float  e aloha é um array de floats. Um array em C é  um ponteiro para seu primeiro elemento. Portanto, aloha é o endereço de memória do primeiro elemento do array.

----------------------------------------------------------------------------------------------------------------------

Questao 13:

O que é memory leak? Procure 3 exemplos de programas em C que apresentem memory leak e explique o que acontece em cada um deles.


<resposta da questao 13>

Memory leak (vazamento de memória) é um problema comum em programação, especialmente em linguagens que gerenciam manualmente a alocação e desalocação de memória, como C e C++. Ocorre quando um programa aloca dinamicamente memória durante sua execução, mas não libera essa memória adequadamente quando não é mais necessária. Como resultado, a memória alocada permanece ocupada mesmo após não ser mais utilizada pelo programa, levando a um desperdício de memória. Se um programa continuar alocando memória sem liberá-la, ele eventualmente esgotará toda a memória disponível no sistema, levando a falhas de execução.

Exemplo 1

#include <stdlib.h>

int main() {
    while(1) {
        int *p = malloc(sizeof(int)); // Aloca memória dinamicamente
        // Não há desalocação de memória
    }
    return 0;
}

Neste programa, o loop while aloca continuamente memória para um novo inteiro em cada iteração, mas nunca libera essa memória. Isso resulta em um vazamento de memória constante, pois a memória alocada nunca é desalocada.

Exemplo 2

#include <stdlib.h>

int main() {
    int *p = malloc(10 * sizeof(int)); // Aloca memória para 10 inteiros
    p = malloc(20 * sizeof(int)); // Aloca mais memória para 20 inteiros, sem liberar a memória anterior
    return 0;
}

Neste programa, o ponteiro p é inicialmente alocado para armazenar espaço para 10 inteiros, mas depois é realocado para armazenar espaço para 20 inteiros, sem liberar a memória alocada anteriormente. Isso resulta em uma perda de referência para a memória originalmente alocada e causa um vazamento de memória, pois essa memória nunca será desalocada.


Exemplo 3

#include <stdlib.h>

int main() {
    int *p = malloc(sizeof(int)); // Aloca memória dinamicamente
    p = NULL; // Libera a referência para a memória sem desalocá-la
    return 0;
}

Neste programa, o ponteiro p é inicialmente alocado para armazenar espaço para um inteiro, mas depois a referência para essa memória é perdida ao atribuir NULL a p, sem desalocar a memória previamente alocada. Isso resulta em uma perda de memória, pois não há mais como acessar ou liberar a memória alocada.

----------------------------------------------------------------------------------------------------------------------

Questao 14:

O que é um ponteiro para uma função? Pesquise na Internet referências sobre o assunto e escreva um pequeno programa exemplificando o uso deste recurso. Explique seu programa, comentando cada uma das linhas de código.

<resposta da questao 14>

Um ponteiro para uma função em C é um tipo de dado que armazena o endereço de memória de uma função. Assim como os ponteiros para variáveis, os ponteiros para funções também podem ser utilizados para acessar e manipular funções de forma dinâmica durante a execução do programa. Isso oferece flexibilidade ao seu programa, pois permite que você, por exemplo, passe uma função como argumento para outra função ou a armazene em uma estrutura de dados para ser usada posteriormente, possibilitando uma programação mais dinâmica e poderosa.

Exemplo de um programa em C onde usamos ponteiros para funções:

#include <stdio.h>

// Definição da função soma
int soma(int a, int b) {
    return a + b;
}

// Definição da função produto
int produto(int a, int b) {
    return a * b;
}


int main() {
    int num1, num2;
    printf("Digite dois números inteiros: ");
    scanf("%d %d", &num1, &num2); // Nessa linha os dois números digitados são lidos e levados para a memória

    // Declaração dos ponteiros para funções 
    int (*funcaoSoma)(int, int) = soma; 
    int (*funcaoProduto)(int, int) = produto;

    // Chama as funções através dos ponteiros
    int resultadoSoma = funcaoSoma(num1, num2);
    int resultadoProduto = funcaoProduto(num1, num2);

    // Exibe os resultados
    printf("Soma: %d\n", resultadoSoma);
    printf("Produto: %d\n", resultadoProduto);

    return 0;
}


----------------------------------------------------------------------------------------------------------------------

Questao 15:

Implemente em linguagem C uma função em um programa de computador que leia n valores do tipo float e os apresente em ordem crescente. Utilize alocação dinâmica de memória para realizar a tarefa.

<resposta da questao 15>


#include <stdio.h>  //readFloats

// Função para ler n valores float
float *ler(int n) {
    float *values = (float *)malloc(n * sizeof(float)); // Aloca memória dinamicamente
    printf("Digite %d valores float:\n", n); 
    for (int i = 0; i < n; i++) {
        scanf("%f", &values[i]);
    }
    return values;
} 

// Função para ordenar os valores em ordem crescente usando a função Bubble Sort
void bubbleSort(float *values, int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (values[j] > values[j + 1]) {
                // Troca os valores
                float temp = values[j];
                values[j] = values[j + 1];
                values[j + 1] = temp;
            }
        }
    }
}

// Função para apresentar os valores em ordem crescente   
void Imprime(float *values, int n) {
    printf("Valores em ordem crescente:\n");
    for (int i = 0; i < n; i++) {
        printf("%.2f ", values[i]);
    }
    printf("\n");
}

int main() {
    int n;
    printf("Qual a quantidade de valores que você deseja ordenar: ");
    scanf("%d", &n);

       float *values = ler(n);
        bubbleSort(values, n);
        Imprime(values, n);
        free(values); // Libera a memória alocada
    return 0;
}
----------------------------------------------------------------------------------------------------------------------

Questao 16:

Reimplemente o programa da questão anterior utilizando a função qsort() do C. Comente o seu
código, explicando o que faz cada uma das linhas.


<resposta da questao 16>

A função qsort em C é usada para ordenar um array de elementos em ordem crescente ou decrescente. Ela é parte da biblioteca padrão de C (<stdlib.h>) e segue o algoritmo de classificação quicksort.

A linha de comando pardrão associada à função qsort é:

void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));

onde:

A função qsort em C é usada para ordenar um array de elementos em ordem crescente ou decrescente. Ela é parte da biblioteca padrão de C (<stdlib.h>) e segue o algoritmo de classificação quicksort, que é eficiente para a maioria dos casos práticos.

Aqui está a assinatura da função qsort:

void qsort(void *p, size_t n, size_t size, int (*comp)(const void *, const void *));

Onde:

1)p: É o ponteiro para o primeiro elemento do array a ser ordenado.
2)n: É o número de elementos no array.
3)size: É o tamanho de cada elemento do array, em bytes.
4)comp: É um ponteiro para a função de comparação que determina a ordem dos elementos. Essa função recebe dois ponteiros const void * como argumentos e retorna um valor inteiro negativo se o primeiro argumento deve ser ordenado antes do segundo, um valor positivo se o segundo deve ser ordenado antes do primeiro e zero se os dois elementos são considerados iguais.

A função qsort reorganiza os elementos do array base de acordo com a função de comparação fornecida. Após a execução da função, os elementos estarão ordenados em relação à comparação especificada.

A seguir usamos a função qsort para implementar um programa que que leia n valores do tipo float e os apresente em ordem crescente

const float *float_a = (const float *)a; e const float *float_b = (const float *)b;: Essas linhas convertem os ponteiros a e b (que são ponteiros genéricos do tipo void *) em ponteiros para floats.

#include <stdio.h>
#include <stdlib.h>

// Função para comparar dois floats 

//Esta função comp recebe dois ponteiros genéricos (void *) que são convertidos em ponteiros para floats (float *). Em //seguida, compara os valores apontados por esses ponteiros e retorna -1 se o primeiro for menor, 1 se o segundo for //menor e 0 se forem iguais.

int comp(const void *a, const void *b) {
    float float_a = *((const float *)a);
    float float_b = *((const float *)b);

    if (float_a < float_b) return -1;
    if (float_a > float_b) return 1;
    return 0;
}

int main() {
    int n;

    printf("Digite a quantidade de valores float que deseja ordenar: ");
    scanf("%d", &n);

    // Aloca memória dinamicamente para armazenar os valores float
    float *values = (float *)malloc(n * sizeof(float));
    
    // Lê os valores float
    printf("Digite %d valores float:\n", n);
    for (int i = 0; i < n; i++) {
        scanf("%f", &values[i]);
    }

    // Ordena os valores usando qsort
    qsort(values, n, sizeof(float), comp);

    // Apresenta os valores ordenados em ordem crescente
    printf("Valores em ordem crescente:\n");
    for (int i = 0; i < n; i++) {
        printf("%.2f ", values[i]);
    }
    printf("\n");

    // Libera a memória alocada
    free(values);

    return 0;
}



----------------------------------------------------------------------------------------------------------------------

Questao 17:

Utilize a ideia do ponteiro para função pela função qsort() para implementar sua própria função de ordenação, mas que seja capaz de ordenar apenas inteiros do tipo int. Para isso, sua função deverá receber, entre outros argumentos, um ponteiro para a função de comparação que determinará como os elementos do array serão ordenados.


<resposta da questao 17>

#include <stdio.h> 
#include <stdlib.h>

// Função para comparar dois floats para qsort
int compare(const void *a, const void *b) {  
    const float *float_a = (const float *)a;
    const float *float_b = (const float *)b;

    if (*float_a < *float_b) return -1;
    else if (*float_a > *float_b) return 1;
    else return 0;
}

// Função para ler n valores float
float* ler(int n) {
    float *values = (float *)malloc(n * sizeof(float)); // Aloca memória dinamicamente
    printf("Digite %d valores float:\n", n);
    for (int i = 0; i < n; i++) {
        scanf("%f", &values[i]);
    }

    return values;
}

// Função para apresentar os valores em ordem crescente usando qsort
void Imprime(float *values, int n) {
    // Ordena os valores usando qsort
    qsort(values, n, sizeof(float), compare);

    // Apresenta os valores ordenados em ordem crescente
    printf("Valores em ordem crescente:\n");
    for (int i = 0; i < n; i++) {
        printf("%.2f ", values[i]);
    }
    printf("\n");
}

int main(){
    int n;

    printf("Digite a quantidade de valores float que deseja ordenar: ");
    scanf("%d", &n);

    float *values = ler(n);
    if (values != NULL) {
        Imprime(values, n);
        free(values); // Libera a memória alocada
    }

    return 0;
}


----------------------------------------------------------------------------------------------------------------------

Questao 18:

Procure na internet mecanismos que possibilitem medir tempos de execução de rotinas  computacionais. Geralmente, estas medidas são realizadas com o auxílio de funções em C que lêem a hora no sistema (sistemas Unix e Windows geralmente usam funções diferentes).  Utilizando os conhecimentos que você obteve com sua pesquisa, meça os tempos de execução das implementações que você criou para os dois problemas de ordenação anteriores,  considerando apenas arrays de elementos tipo int e compare os resultados obtidos. O que se conclui nesse caso?


<resposta da questao 18>

Existem várias maneiras de medir o tempo de execução de rotinas computacionais em linguagem C. A seguir listamos algumas delas:

1)Funções de Tempo Padrão: A biblioteca padrão de C fornece funções para medir o tempo, como clock() e time(). A função clock() retorna o número de ciclos de clock decorridos desde o início do programa, enquanto time() retorna o tempo atual em segundos desde 1º de janeiro de 1970.

2)<sys/time.h>: Esta biblioteca fornece estruturas de dados como struct timeval e funções como gettimeofday() para obter tempos com precisão de microssegundos. Isso pode ser útil para medir tempos de execução mais precisos.

3)<time.h>: A biblioteca de tempo padrão de C fornece a função clock_gettime(), que pode ser usada para medir tempos com precisão de nanossegundos. Isso requer incluir a biblioteca <time.h> e compilar com a opção -lrt.

Exemplo usando a função clock:

#include <stdio.h>
#include <time.h>

void minhaRotina() {
    // Rotina que será medida
    int i;
    for (i = 0; i < 1000000; i++) {
        // Algum trabalho a ser feito
    }
}

int main() {
    clock_t inicio, fim;
    double tempoDecorrido;

    inicio = clock();
    minhaRotina();
    fim = clock();

    tempoDecorrido = ((double)(fim - inicio)) / CLOCKS_PER_SEC;
    printf("Tempo de execução: %f segundos\n", tempoDecorrido);

    return 0;
}

A saída desse programa foi: Tempo de execução: 0.000002 segundos


A seguir vamos usar esses recusos para aferir o tempo de excução dos programas exibidos nas duas questões anteriores.



----------------------------------------------------------------------------------------------------------------------

Questao 19:

Escreva uma função em linguagem C que escreva em um vetor a soma dos elementos correspondentes de outros dois vetores (os tamanhos dos vetores devem ser fornecidos pelo usuário). Por exemplo, se o primeiro vetor contiver os elementos 1, 3, 0 e -2, e o segundo vetor contiver os elementos 3, 5, -3 e 1, o vetor de soma terá valores resultantes iguais a 4, 8, -3 e -1. A função deve receber 4 argumentos: os nomes dos três vetores e o número de elementos presentes em cada vetor. Exemplo:

soma_vetores(vet1, vet2, resultado, 4);

<resposta da questao 19>

#include <stdio.h>
#include <stdlib.h>

void soma_vetores(const int *vetor1, const int *vetor2, int *resultado, int tamanho) {
    for (int i = 0; i < tamanho; i++) {
        resultado[i] = vetor1[i] + vetor2[i];
    }
}

int main() {
    int tamanho;

    // Obter o tamanho dos vetores do usuário
    printf("Digite o tamanho dos vetores: ");
    scanf("%d", &tamanho);

    // Alocar memória para os vetores
    int *vetor1 = (int *)malloc(tamanho * sizeof(int));
    int *vetor2 = (int *)malloc(tamanho * sizeof(int));
    int *resultado = (int *)malloc(tamanho * sizeof(int));

    // Verificar alocamento de memória
    if (vetor1 == NULL || vetor2 == NULL || resultado == NULL) {
        printf("Erro de alocação de memória.\n");
        return 1;
    }

    // Obter os valores para o primeiro vetor
    printf("Digite os elementos do primeiro vetor:\n");
    for (int i = 0; i < tamanho; i++) {
        scanf("%d", &vetor1[i]);
    }

    // Obter os valores para o segundo vetor
    printf("Digite os elementos do segundo vetor:\n");
    for (int i = 0; i < tamanho; i++) {
        scanf("%d", &vetor2[i]);
    }

    // Calcular a soma dos vetores
    soma_vetores(vetor1, vetor2, resultado, tamanho);

    // Exibir o vetor resultado
    printf("A soma dos vetores é:\n");
    for (int i = 0; i < tamanho; i++) {
        printf("%d ", resultado[i]);
    }
    printf("\n");

    // Liberar memória alocada
    free(vetor1);
    free(vetor2);
    free(resultado);

    return 0;
}

----------------------------------------------------------------------------------------------------------------------

Questao 20:

Crie uma função capaz de realizar multiplicação matricial da forma C = AxB. A função deve receber 6 argumentos: os ponteiros para as matrizes A, B e C, o número de linhas e colunas de A e o número de colunas de B (assuma que o número de coluna de A é igual ao número de linhas de B). O resultado da multiplicação deve ficar armazenado em C. Crie um programa para testar sua implementação, capaz de utilizar a função de multiplicação e imprimir as três matrizes. A função criada para multiplicação não deve realizar nenhum tipo de saída de dados no terminal. Exemplo: para multiplicar duas matrizes (A e B) de dimensões 2x3 e 3x4, respectivamente (o resultado deve ficar armazenado em C).

multiplica_matrizes(A, B, C, 2, 3, 4);

<resposta da questao 20>

Não consegui fazer!

----------------------------------------------------------------------------------------------------------------------

Questao 21:

(ENADE, 2023) Memory leak, ou vazamento de memória, é um problema que ocorre em sistemas computacionais quando uma parte da memória, alocada para uma determinada operação, não é liberada quando se torna desnecessária. Na linguagem C, esse tipo de problema é quase sempre relacionado ao uso incorreto das funções malloc( ) e free( ). Esse erro de programação pode levar a falhas no sistema se a memória for completamente consumida. Um dos trechos abaixo apresenta um vazamento de memória. Identifique-o e justifique sua resposta.

A void f( ){
void *s;
s = malloc(50);
free(s);
}

B int f( ){
float *a;
return 0;
}

C int f(char *data){
void *s;
s = malloc(50);
int size = strlen(data);
if (size > 50)
return(-1);
free(s);
return 0;
}


D int *f(int n){
int *num = malloc(sizeof(int)*n);
return num;
}

int main(void){
int *num;
num = f(10);
free(num);
return 0;
}

E void f(int n){
char *m = malloc(10);
char *n = malloc(10);
free(m);
m = n;
free(m);
free(n);
}


<resposta da questao 21>

O trecho onde identificamos um vazamento de memória é o seguinte:


E void f(int n){
char *m = malloc(10);
char *n = malloc(10);
free(m);
m = n;
free(m);
free(n);
}

Nesse trecho a função f aloca memória para o ponteiro m usando malloc(10). Em seguida, aloca memória para o ponteiro n também usando malloc(10). A memória alocada para m é liberada corretamente usando free(m). Em seguida, o valor do ponteiro n é atribuído ao ponteiro m (m = n;), fazendo com que m agora aponte para a mesma memória que n. A memória alocada para m é novamente liberada com free(m). No entanto, como m aponta para a mesma memória que n agora, essa linha libera a memória previamente alocada para n. Finalmente, a memória alocada para n é liberada corretamente com free(n). Portanto, o trecho de código apresenta um vazamento de memória porque a memória alocada para n não é mais liberada após a atribuição m = n;.


----------------------------------------------------------------------------------------------------------------------

Questao 22:


(ENADE, 2023) Na programação de sistemas embarcados, algumas posições de memória servem para diferentes propósitos, não apenas para armazenar valores. Em algumas dessas memórias, cada um os bits possui um significado diferente, sendo necessário manipulá-los individualmente ou em pequenos grupos. Por isso, o conhecimento da álgebra booleana, bem como dos operadores tilizados para realizar operações binárias nas linguagens de programação, é essencial para o desenvolvimento desse tipo de sistema. A partir dessas informações, observe o código apresentado a seguir, escrito na linguagem C, que faz uso de operações binárias sobre variáveis inteiras.


#include <stdio.h>
int main(){
int a, b;
int x, y, z;
scanf("%d %d", &a, &b);
x = a; y = b; z = a + b;
while (a) {
x = x | b;
y = y ^ a;
z = z & (a+b);
a = a >> 1;
b = b << 1;
}
printf ("%d %d %d\n", x, y, z);
return 0;
}

Após a chamada desse programa, caso o usuário entre com os valores 10 e 1, nessa ordem, qual
será, exatamente, o valor da saída do programa?



<resposta da questao 22>

O funcionamento desse programa é o seguinte:

O programa lê dois números inteiros a e b fornecidos pelo usuário. Inicializa as variáveis x, y e z com os valores de a, b e a + b, respectivamente.
Entra em um loop while que continua enquanto a for diferente de zero.
Durante cada iteração do loop:
x = x | b;: realiza uma operação de OR (ou) bit a bit entre x e b, atribuindo o resultado de volta a x.
y = y ^ a;: realiza uma operação de XOR (ou exclusivo) bit a bit entre y e a, atribuindo o resultado de volta a y.
z = z & (a+b);: realiza uma operação de AND bit a bit entre z e a+b, atribuindo o resultado de volta a z.
a = a >> 1;: desloca a para a direita em uma posição, o que é equivalente a dividir a por 2.
b = b << 1;: desloca b para a esquerda em uma posição, o que é equivalente a multiplicar b por 2.
Quando a se torna zero, o loop termina.

Imprime os valores finais de x, y e z 15, 13 e 0. A explicação é a seguinte:

Antes de mais nada lembremos os resultados oferecidos pelos operadores OR, XOR e AND.  

OR = 1 apenas quando pelos menos um dos bits comparados é 1.
XOR =1 apenas quando os dois bits comparados são diferentes Um deles é 0 e o outro é 1).
AND = 1 apenas quando os dois bits comparados são iguais a 1.

Entrando com os valores 10 e 1 nessa ordem, o programa irá ler a=10 e b=1. Em seguida x = a; y = b; z = a + b faz com que x=10, y=1 e z=11.

O loop vai iniciar com a=10.  Dentro do loop, 

x = 10 | 1 = (1010)_2 OR (0001)_2 = (1011)_2

y=1^10 = (0001)_2 XOR (1010)_2 = (1011)_2

z=11 & 11 = (1011)_2 AND (1011)_2 = (1011)_2

a=10>> 1 = (1010)_2 >> 1 = (0101)_2

b=1<<1 = (0001)_2 << 1 = (0010)_2

Como nesse momento a=(0101)_2 que é difente de zero, loop ocorre mais uma vez. Vejamos:

x =(1011)_2 |  (0010)_2 = (1011)_2 OR  (0010)_2 = (1011)_2

y= (1011)_2 ^(0101)_2= (1011)_2 XOR (0101)_2=(1110)_2

z=(1011)_2 & (0111)_2 = (1011)_2 AND (0111)_2=(0011)_2

a= (0101)_2>>1 = (0010)_2

b= (0010)_2 << 1= (0100)_2

Neste ponto como a=(0010)_2, que é diferente de zero. Então, o loop continua:

x = (1011)_2 | (0100)_2 = (1011)_2 OR (0100)_2 = (1111)_2

y= (1110)_2^(0010)_2=(1110)_2 XOR (0010)_2=(1100)_2

z=(0011)_2 & (0110)_2= (0011)_2 AND (0110)_2=(0010)_2

a=  (0010)_2>>1 = (0001)_2

b=  (0100)_2<<1 = (1000)_2

Neste ponto como a=(0001)_2, que é diferente de zero o loop continua:

x =  (1111)_2 |  (1000)_2 =  (1111)_2 OR  (1000)_2 =(1111)_2

y=  (1100)_2^(0001)_2 = (1100)_2 XOR (0001)_2 = (1101)_2


z=(0010)_2 & (1001)_2= (0010)_2 AND (1001)_2=(0000)_2

a=  (0001)_2 >>1 = (0000)_2

b=  (1000)_2>>1 =(10000)_2

Neste ponto a=(0000)_2 é nulo, finaliza o loop e são impressos os valores de x, y, e z que são:

x=(1111)_2=1.2^3+1.2^2+1.2^1+1.2^0=15

y=(1101)_2=1.2^3+1.2^2+0.2^1+1.2^0=13

z=(0000)_2=0


----------------------------------------------------------------------------------------------------------------------

Questao 23:

(ENADE, 2021) Observe o código abaixo escrito na linguagem C.

#include <stdio.h>
#define TAM 10
int funcaol(int vetor[], int v){
int i;
for (i = 0; i < TAM; i++){
if (vetor[i] == v)
return i;
}
return -1;
}
int funcao2(int vetor[], int v, int i, int f){
int m = (i + f) / 2;
if (v == vetor[m])
return m;
if (i >= f)
return -1;
if (v > vetor[m])
return funcao2(vetor, v, m+l, f);
else
return funcao2(vetor, v, i, m-1);
}
int main(){
int vetor[TAM] = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
printf("%d - %d", funcao1(vetor, 15), funcao2(vetor, 15, 0, TAM-1));
return 0;
}

A respeito das funções implementadas, avalie as afirmações a seguir.

I. O resultado da impressão na linha 24 é: 7 - 7.
II. A função funcao1, no pior caso, é uma estratégia mais rápida do que a funcao2.
III. A função funcao2 implementa uma estratégia iterativa na concepção do algoritmo.

É correto o que se afirma em:

IV. I, apenas.
V. III, apenas.
VI. I e II, apenas.
VII. II e III, apenas.
VIII. I, II e III.
Justifique sua resposta.


<resposta da questao 23>

Apenas a I é correta.

Vamos descrever a execução do programa a partir do main.

Inicialmente o vetor[TAM] recebe {1, 3, 5, 7, 9, 11, 13, 15, 17, 19}.

Em seguida a funcao1 é chamada 

int funcaol(int vetor[], int v){
int i;
for (i = 0; i < TAM; i++){
if (vetor[i] == v)
return i;
}

Nesse trecho  se  v[i] for igual ao inteiro v=15, ela retorna o número i. Ora, como entre as coordenadas do vetor[TAM] só aparece um 15 na posição i=7, segue que a expressão funcao1(vetor, 15) retorna como resposta o número 7.

Em seguida aparece a expressão funcao2(int vetor[], int v, int i, int f)=funcao2(int vetor[], 15, 0,  9). A funcao2(vetor, 15, 0, TAM - 1): Realiza a busca  pelo valor 15 no array vetor e retorna o índice onde esse valor é encontrado ou -1 caso contrário. No caso, o valor 15 é encontrado no índice 7 do array vetor.

Portanto, a saída impressa será 7 - 7. Isso indica que tanto a função funcaol quanto a função funcao2 retornam o mesmo índice para o valor 15 no array vetor, o que revela que a afirmação I é correta. 


A firmação II é falsa, pois a funcao1 e a funcao2 fazem basicamente a mesma coisa a busca pelo 15 e registrar o índice da posição onde o 15 de senconte no vetor[TAM].

A airmação III também é falsa. A funcao2 não recebe um valor a partir dos seus valores anteriores, o que não caracterizaria uma estratégia iterativa na concepção do algoritmo.

----------------------------------------------------------------------------------------------------------------------

Questao 24:

Um usuário precisa implementar o controle de uma matriz de leds com 8 x 8 elementos. Para isso, ele criou um programa em C dotado de uma matriz da forma unsigned char m[8][8]; para armazenar os estados dos leds. Como existem apenas dois estados possíveis para os leds (aceso ou apagado), ele assumiu que leds acessos seriam denotados pelo inteiro "1" nessa matriz e leds apagados seriam denotados pelo inteiro "0". Ocorre que a função que controla os leds exige que a informação que controla a matriz seja enviada via porta serial usando uma função que recebe um único inteiro não sinalizado de 64 bits, da forma send(unsigned long estado). Nesse inteiro, os bytes mais significativos deverão guardar os estados das linhas iniciais da matriz de leds, enquanto os bytes menos significativos devem guardar os estados das linhas finais da matriz. Assim, é necessário que cada estado previsto na matriz m seja codificado em um bit correspondente na variável enviada pela função. Crie um programa em linguagem C para realizar essa codificação e explique na forma de comentários como sua codificação da matriz m na variável de 64 bits foi realizada.

<resposta da questao 24>

#include <stdio.h>

// Função para enviar o estado via porta serial
void send(unsigned long estado) {
    // Simulando o envio do estado
    printf("Estado enviado via porta serial: %llu\n", estado);
}

int main() {
    // Matriz de LEDs
    unsigned char m[8][8] = {
        {1, 0, 1, 0, 1, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 0, 1},
        {1, 0, 1, 0, 1, 0, 1, 0},
        {0, 1, 0, 1, 0, 1, 0, 1}
    };

    // Variável para armazenar o estado de cada LED
    unsigned long estado = 0;

    // Codificação da matriz na variável de 64 bits
    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            // Se o LED estiver aceso, definir o bit correspondente como 1
            if (m[i][j] == 1) {
                estado |= (1ULL << (i * 8 + j));
            }
        }
    }

    // Enviar o estado via porta serial
    send(estado);

    return 0;
}

--------------------------------------------------------------------------------------------------------------------

Questao 25:

Um programador precisa desenvolver uma aplicação em linguagem C para manipular matrizes  capazes de armazenar representações de modelos tridimensionais. Entende-se que o tamanho da matriz é definido pelo usuário e esta deve ser alocada dinamicamente usando malloc() em tempo de execução. O processo de criar um modelo na matriz consiste em atribuir aos seus elementos os valores inteiros “1” ou “0” para simbolizar que há ou não parte do modelo naquela posição. Uma analogia para o modelo seria que a criação funciona como no jogo "Minecraft", onde "0" representaria a ausência de objeto e "1" representaria a presença de objetos. Nesta aplicação, as matrizes devem ser definidas como tipos de dados int. Isto posto, pede-se que o programador prepare os algoritmos de alocação dinâmica (usando malloc()/free()) para guardar os dados da matriz tridimensional e crie um programa de testes para verificar se a sua implementação foi realizada corretamente de modo a garantir as seguintes condições:

a. O usuário do programa de testes deverá poder fornecer o tamanho da matriz tridimensional que deseja manipular, inserindo as dimensões da altura, largura e profundidade desta.

b. O usuário do programa de testes poderá solicitar a impressão de um dos planos da matriz tridimensional.

c. O usuário do programa de testes poderá modificar o estado de um dos elementos da matriz. Insira no seu código comentários para indicar como as posições da matriz poderão ser acessadas.

<resposta da questao 25>

Não consegui fazer!

----------------------------------------------------------------------------------------------------------------------



